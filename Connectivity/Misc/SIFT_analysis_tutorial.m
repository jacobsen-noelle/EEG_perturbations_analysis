%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SCRIPTING EXAMPLE FOR THE SOURCE INFORMATION FLOW TOOLBOX (SIFT)    %%%
%%% SIFT Version: 1.0-beta                                              %%%
%%%                                                                     %%%
%%% THIS DOES NOT WORK WITH VERSION 0.97-alpha OR EARLIER               %%%
%%%                                                                     %%%
%%% This example demonstrates how to use SIFT from the command-line or  %%%
%%% in a script. This example applies to SIFT 1.0-beta.                 %%%
%%% For additional information on the below steps, please consult the   %%%
%%% SIFT manual located at http://sccn.ucsd.edu/wiki/SIFT               %%%
%%% Author: Tim Mullen (C) 2013, SCCN, INC, UCSD                        %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%STEP 0: Set Options
clear; close all; clc;
cd /data/projects/stepeter/BVR/Data/
% addpath(genpath('/home/speterson/Documents/eeglab13_0_1b_octave_rem'))
%rmpath('/home/speterson/Documents/eeglab13_0_1b/functions/octavefunc/signal')
addpath(genpath('/home/speterson/Documents/eeglab13_5_4b'))

% Add necessary dependent paths
addpath(genpath('/home/speterson/Documents/Grant/common/'))

% Edit eeg_options.m file (according to SIFT tutorial)
pop_editoptions( 'option_storedisk', 0, 'option_savetwofiles', 1, ...
    'option_single', 0, 'option_memmapdata', 0, ...
    'option_computeica', 1, 'option_scaleicarms', 1, 'option_rememberfolder', 1);

global EEG ALLEEG CURRENTSET
%% STEP 1: Load Data

% We will begin by loading up the 'RespWrong.set' (and optionally 'RespCorr.set') datasets located in the 
% /Data/ folder within the Sample Data package
% (you can download this package from the SIFT website or at 
% ftp://sccn.ucsd.edu/pub/tim/SIFT/SIFT_SampleData.zip)
EEGsets_outpath='/home/stepeter/HNL_Cluster/share/data3/stepeter/Projects/MISM/Data/SIFT';
conds={'Sit','Stn','Wlk'};
% figSavePath='/data/projects/stepeter/BVR/Data/BVR_final_noHScleaned2_conn';
for subjnum=[10 15] %[1:6 8 10 15]
    for j=1:3
        %EEG = pop_loadset;
        
        EEG=pop_loadset([EEGsets_outpath filesep conds{j} filesep 'Epch_mismatches_' num2str(subjnum) '_1pt00_Mism_on_' conds{j} '.set']);
        EEG.condition=conds{j};
        
        %%STEP 2: Define key Processing Parameters

        Components          = [];                           % these are the components/channels to which we'll fit our multivariate model (if empty, select all in ica weight matrix)
        WindowLengthSec     = 0.4;                          % sliding window length in seconds
        WindowStepSizeSec   = 0.01;                         % sliding window step size in seconds
        NewSamplingRate     = [128];                           % new sampling rate (if downsampling)
        EpochTimeRange      = [-0.5-0.5 2+0.5]; % this is the time range (in seconds) to analyze (relative to event at t=0)
        GUI_MODE            = 'nogui';                      % whether or not to show the Graphical User Interfaces. Can be 'nogui' or anything else (to show the gui)
        VERBOSITY_LEVEL     = 1;                            % Verbosity Level (0=no/minimal output, 2=graphical output)

        disp('DONE :)');

        %%STEP 3: Pre-process the data

        disp('===================================')
        disp('PRE-PROCESSING DATA');

        % select time range
        EEG = pop_select( EEG,'time',EpochTimeRange );
        % select components
        % EEG = pop_subcomp( EEG, setdiff_bc(1:EEG.nbchan,Components), 0);
        if isempty(Components)
            Components=1:size(EEG.icaweights,1);
        end
        % resample data
        if ~isempty(NewSamplingRate)
            EEG = pop_resample( EEG, NewSamplingRate, 0.8, 0.4);
        end
        % convert list of components to cell array of strings
        ComponentNames = strtrim(cellstr(num2str(Components'))); 

        % apply the command to pre-process the data
        [EEG] = pop_pre_prepData(EEG,GUI_MODE, ...
                'VerbosityLevel',VERBOSITY_LEVEL,   ...
                'SignalType',{'Components'},  ...
                'VariableNames',ComponentNames,   ...
                'Detrend',  ...
                    {'verb' VERBOSITY_LEVEL ...
                    'method' {'linear'} ...
                    'piecewise' ...
                        {'seglength' 0.33   ...
                         'stepsize' 0.0825} ...
                    'plot' false},  ...
                'NormalizeData',    ...
                    {'verb' 0       ...
                     'method' {'time' 'ensemble'}},   ...
                'resetConfigs',true,    ...
                'badsegments',[],       ...
                'newtrials',[],         ...
                'equalizetrials',false);

        disp('DONE with PRE-PROCESSING DATA :)');
        disp('===================================')

        %%STEP 4: Identify the optimal model order (SELECT 'NO' FOR PROCEEDING TO MODEL FITTING)
        modelOrderCrit='min'; %'elbow';
        disp('===================================')
        disp('MODEL ORDER IDENTIFICATION');

        % Here we compute various model order selection criteria for varying model
        % orders (e.g. 1 to 30) and visualize the results

        % compute model order selection criteria...
        EEG = pop_est_selModelOrder(EEG,GUI_MODE, ...
                'modelingApproach',         ...
                    {'Segmentation VAR'     ...
                        'algorithm' {'Vieira-Morf'} ...
                        'winStartIdx' []    ...
                        'winlen'  WindowLengthSec    ...
                        'winstep' WindowStepSizeSec  ...
                        'taperfcn' 'rectwin'    ...
                        'epochTimeLims' []      ...
                        'prctWinToSample' 100   ...
                        'normalize' []          ...
                        'detrend' {'method' 'constant'} ...
                        'verb' VERBOSITY_LEVEL},      ...
                'morderRange',[1 20], ... %30] ,  ...
                'downdate',true,        ...
                'runPll',[],            ...
                'icselector',{'sbc' 'aic' 'fpe' 'hq'},  ...
                'winStartIdx',[],       ...
                'epochTimeLims',[],     ...
                'prctWinToSample',80,   ...
                'plot', [], ...
                'verb',VERBOSITY_LEVEL);

        if strcmp(modelOrderCrit,'min')
            % To plot the results, use this:
%             handles = vis_plotOrderCriteria(EEG.CAT.IC,'conditions', [],    ...
%                                                         'icselector', {'sbc','aic','fpe','hq'},  ...
%                                                         'minimizer', {'min'}, ...
%                                                         'prclim', 90);
% 
%             % If you want to save this figure you can uncomment the following lines:
%             %
%             for i=1:length(handles)
%                 saveas(handles(i),sprintf('BVR_final_noHScleaned2_conn/subj%d_%d_orderResults%d.fig',subjnum,j,i));
%             end
%             close(handles);

            % Finally, we can automatically select the model order which minimizes one
            % of the criteria (or you can set this manually based on above figure)
            ModelOrder = ceil(mean(EEG(1).CAT.IC.hq.popt));
        elseif strcmp(modelOrderCrit,'elbow')
            % As an alternative to using the minimum of the selection criteria over 
            % model order, you can find the "elbow" in the plot of model order versus
            % selection criterion value. This is useful in cases where the selection
            % criterion does not have a clear minimum. For example, the lines below
            % plot and select the elbow location (averaged across windows) for the AIC 
            % criterion
            %
%             handles = vis_plotOrderCriteria(EEG(1).CAT.IC,'conditions',[], 'icselector', {'sbc','aic','fpe','hq'},...
%                                                 'minimizer',{'elbow'},'prclim', 90);
% 
%             for i=1:length(handles)
%                 saveas(handles(i),sprintf('BVR_final_noHScleaned2_conn/subj%d_%d_orderResults%d.fig',subjnum,j,i));
%             end
%             close(handles);

            ModelOrder = ceil(mean(EEG(1).CAT.IC.aic.pelbow));
        end
        disp(['Model Order Selected is: ' num2str(ModelOrder)]);
        disp('DONE with MODEL ORDER IDENTIFICATION :)');
        disp('===================================')

        %%STEP 5: Fit the VAR model

        disp('===================================')
        disp('MODEL FITTING');

        % Here we can check that our selected parameters make sense
        fprintf('===================================================\n');
        fprintf('MVAR PARAMETER SUMMARY FOR CONDITION: %s\n',EEG.condition);
        fprintf('===================================================\n');
        est_dispMVARParamCheck(EEG,struct('morder',ModelOrder','winlen',WindowLengthSec,'winstep',WindowStepSizeSec,'verb',VERBOSITY_LEVEL));

        % Once we have identified our optimal model order, we can fit our VAR model.

        % Fit a model using the options specifed for model order selection (STEP 4)
        [EEG] = pop_est_fitMVAR(EEG,GUI_MODE, ...
                    EEG.CAT.configs.est_selModelOrder.modelingApproach, ...
                    'ModelOrder',ModelOrder);

        [msg1 msg2 msg3]=est_checkMVARParams(EEG,EEG.CAT.configs.est_fitMVAR);
        disp('Info:');
        for p=1:length(msg1)
            disp(msg1{1,p});
        end
        disp('Warning:');
        for p=1:length(msg2)
            disp(msg2{1,p});
        end
        disp('Error:');
        for p=1:length(msg3)
            disp(msg3{1,p});
        end
        % Note that EEG.CAT.MODEL now contains the model structure with
        % coefficients (in MODEL.AR), prediction errors (MODEL.PE) and other
        % self-evident information

        % Alternately, we can fit the VAR parameters using a Kalman filter (see
        % doc est_fitMVARKalman for more info on arguments)
        %
        % EEG.CAT.MODEL = est_fitMVARKalman(EEG,0,'updatecoeff',0.0005,'updatemode',2,'morder',ModelOrder,'verb',2,'downsampleFactor',50);
        disp('DONE with MODEL FITTING :)');
        disp('===================================')

        %%STEP 6: Validate the fitted model

        disp('===================================')
        disp('MODEL VALIDATION');

        % Here we assess the quality of the fit of our model w.r.t. the data. This
        % step can be slow.

        % We can obtain statistics for residual whiteness, percent consistency, and
        % model stability ...
        [EEG] = pop_est_validateMVAR(EEG,GUI_MODE,...
                                    'checkWhiteness', ...
                                        {'alpha' 0.05 ...
                                         'statcorrection' 'none' ...
                                         'numAcfLags' 50         ...
                                         'whitenessCriteria' {'Ljung-Box' 'ACF' 'Box-Pierce' 'Li-McLeod'} ...
                                         'winStartIdx' [] ...
                                         'prctWinToSample' 100  ...
                                         'verb' 0}, ...
                                     'checkResidualVariance',...
                                        {'alpha' 0.05 ...
                                         'statcorrection' 'none' ...
                                         'numAcfLags' 50    ...
                                         'whitenessCriteria' {}  ...
                                         'winStartIdx' []        ...
                                         'prctWinToSample' 100   ...
                                         'verb' 0}, ...
                                     'checkConsistency',    ...
                                        {'winStartIdx' []   ...
                                         'prctWinToSample' 100 ...
                                         'Nr' []                ...
                                         'donorm' 0         ...
                                         'nlags' []         ...
                                         'verb' 0}, ...
                                     'checkStability',  ...
                                        {'winStartIdx' []   ...
                                         'prctWinToSample' 100 ...
                                         'verb' 0},     ...
                                     'prctWinToSample',70,  ...
                                     'winStartIdx',[],      ...
                                     'verb',VERBOSITY_LEVEL,...
                                     'plot',false);
%Commented out plots
%         % ... and then plot the results
%         handles = [];
%         for k=1:length(EEG)
%             handles(k) = vis_plotModelValidation({EEG(k).CAT.VALIDATION.whitestats}, ...
%                                                  {EEG(k).CAT.VALIDATION.PCstats},         ...
%                                                  {EEG(k).CAT.VALIDATION.stabilitystats});
%         end
% 
%         % If you want to save this figure you can uncomment the following lines:
%         %
%         for i=1:length(handles)
%             saveas(handles(i),sprintf('BVR_final_noHScleaned2_conn/subj%d_%d_validationResults%d.fig',subjnum,j,i));
%         end
%         close(handles);


        % To automatically determine whether our model accurately fits the data you
        % can write a few lines as follows (replace 'acf' with desired statistic):
        %
        if ~all(EEG(1).CAT.VALIDATION.whitestats.acf.w)
%             msgbox('Residuals are not completely white!');
        end

        disp('DONE with MODEL VALIDATION :)');
        disp('===================================')


        %%STEP 7: Compute Connectivity

        disp('===================================')
        disp('CONNECTIVITY ESTIMATION');

        % Next we will compute various dynamical quantities, including connectivity,
        % from the fitted VAR model. We can compute these for a range of
        % frequencies (here 1-40 Hz). See 'doc est_mvarConnectivity' for a complete
        % list of available connectivity and spectral estimators.

        EEG = pop_est_mvarConnectivity(EEG,GUI_MODE, ...
                    'connmethods',{'RPDC' 'dDTF08' 'S'}, ...
                    'absvalsq',true,           ...
                    'spectraldecibels',true,   ...
                    'freqs',[1:64] ,        ...
                    'verb',VERBOSITY_LEVEL); %'freqs',[1,40]

        disp('DONE with CONNECTIVITY ESTIMATION :)');
        disp('===================================')
        EEG.setname = ['Epch_mismatches_' num2str(subjnum) '_1pt00_Mism_on_' conds{j}];
        pop_saveset(EEG, 'filename', EEG.setname, 'filepath', [EEGsets_outpath filesep conds{j}]);
        
        %Visualize the Connectivity estimates in a Time-Frequency Grid
%         EEG = pop_vis_TimeFreqGrid(EEG,GUI_MODE, ...
%                         'plotCondDiff',false,   ...
%                         'vismode','TimeXFrequency', ...
%                         'MatrixLayout', ...
%                             {'Partial' ...
%                              'triu' 'RPDC' 'ut_clim' 100 ...
%                              'tril' 'RPDC' 'lt_clim' 100 ...
%                              'diag' 'RPDC' 'd_clim' 100   ...
%                              'clim' 99.7},  ...
%                          'clim',100,        ...
%                          'timeRange',[],    ...
%                          'freqValues',[1:40],   ...
%                          'windows',[],      ...
%                          'pcontour',[],     ...
%                          'thresholding',    ...
%                             {'Simple'       ...
%                             'prcthresh' [97.5 3]  ...
%                             'absthresh' []},    ...
%                         'baseline',[-1 -0.25] , ...
%                         'fighandles',[],        ...
%                         'smooth',false,         ...
%                         'xord',[],'yord',[],    ...
%                         'plotorder',[],         ...
%                         'topoplot','dipole',    ...
%                         'topoplot_opts',{},     ...
%                         'customTopoMatrix',[],  ...
%                         'dipplot',  ...
%                             {'mri' '' 'coordformat' 'mni' 'dipplotopt' {}}, ...
%                         'nodelabels',ComponentNames,        ...
%                         'foilines',[3 7 15],    ...
%                         'foilinecolor',[0.7 0.7 0.7] ,  ...
%                         'events',{{0 'r' ':' 2}},       ...
%                         'freqscale','linear',           ...
%                         'transform','linear',           ...
%                         'yTickLoc','right',             ...
%                         'titleString','',               ...
%                         'titleFontSize',12,             ...
%                         'axesFontSize',11,              ...
%                         'textColor',[1 1 1] ,           ...
%                         'linecolor',[1 1 1] ,           ...
%                         'patchcolor',[1 1 1] ,          ...
%                         'colormap',jet(64),             ...
%                         'backgroundColor',[0 0 0]);
%         saveas(gca,[figSavePath '/subj' num2str(subjnum) '_' num2str(j) '_conn_viz.fig']);
    end
end
disp('ALL DONE :)');

% %% Run Stats (don't use! takes a really, really long time to run and lots of memory!)
% %Load in EEG sets
% cd /data/projects/stepeter/BVR/Data/
% EEGsets_outpath='/data/projects/stepeter/BVR/Data/BVR_final_noHScleaned2_conn';
% for subjnum=[5:7] %9 11]
%     for j=[81 82 7]
%         disp(subjnum);
%         disp(j);
%         %Load EEG set
%         EEG=[];
%         EEG=pop_loadset([EEGsets_outpath filesep 'FBVR_' num2str(subjnum) '_' num2str(j) '_connectivity.set']);
% 
%         Components          = [];                           % these are the components/channels to which we'll fit our multivariate model
%         WindowLengthSec     = 0.35;                         % sliding window length in seconds
%         WindowStepSizeSec   = 0.01;                         % sliding window step size in seconds
%         NewSamplingRate     = [128];                           % new sampling rate (if downsampling)
%         EpochTimeRange      = [-0.5-0.5*WindowLengthSec 1+0.5*WindowLengthSec]; %[-0.5-0.5*WindowLengthSec 1.5+0.5*WindowLengthSec];   % this is the time range (in seconds) to analyze (relative to event at t=0)
%         GUI_MODE            = 'nogui';                      % whether or not to show the Graphical User Interfaces. Can be 'nogui' or anything else (to show the gui)
%         VERBOSITY_LEVEL     = 1;                            % Verbosity Level (0=no/minimal output, 2=graphical output)
% 
%         %Compute Statistics (This step is slow)
% 
%         disp('===================================')
%         disp('COMPUTING STATISTICS');
%         % number of bootstrap samples to draw
%         NumSamples = 200;
% 
%         % obtain the bootstrap distributions for each condition
%         EEG = mod_pop_stat_surrogateGen(EEG,GUI_MODE, ...
%                 'modelingApproach', EEG.CAT.configs.est_fitMVAR, ...
%                 'connectivityModeling',EEG.CAT.configs.est_mvarConnectivity, ...
%                 'mode',{'Bootstrap' 'nperms' NumSamples 'saveTrialIdx' true}, ...
%                 'autosave',[], ...
%                 'verb',VERBOSITY_LEVEL);
% 
%         % Bootstrap distributions are now stored in EEG.CAT.PConn
%         % This is a structure containing bootstrap estimates of the connectivity,
%         % etc., stored in matrices of size:
%         % [num_vars x num_vars x num_freqs x num_times x num_samples]
% 
% 
%         % we can also replace connectivity estimate with bootstrap estimate
%         % for cnd=1:length(EEG)
%         %     EEG(cnd).CAT.Conn = stat_getDistribMean(EEG(cnd).CAT.PConn);
%         % end
%         %save bootstrap result to new variable so not overwritten with next step
%         EEG.setname = ['FBVR_' num2str(subjnum) '_' num2str(j) '_conn_stats'];
%         pop_saveset(EEG, 'filename', ['FBVR_' num2str(subjnum) '_' num2str(j) '_conn_stats'], 'filepath', ['/data/projects/stepeter/FBVR/Data/BVR_final_noHScleaned2_conn_statsBoot']);
% %         EEG.setname = ['FBVR_group_81_conn_stats'];
% %         pop_saveset(EEG, 'filename', ['FBVR_group_81_conn_stats'], 'filepath', ['/data/projects/stepeter/BVR/Data/BVR_final_noHScleaned2_conn_statsBoot']);
%          
%         disp('DONE with COMPUTING STATISTICS :)');
%         disp('===================================')
% 
%         %%NOTE: alternately, we can also obtain the phase-randomized null distributions for each condition
%         EEG=[];
%         EEG=pop_loadset([EEGsets_outpath filesep 'FBVR_' num2str(subjnum) '_' num2str(j) '_connectivity.set']);
%         % number of null distribution samples to draw
%         NumSamples = 200;
% 
%         EEG = pop_stat_surrogateGen(EEG,GUI_MODE, ...
%                 'modelingApproach', EEG.CAT.configs.est_fitMVAR, ...
%                 'connectivityModeling',EEG.CAT.configs.est_mvarConnectivity, ...
%                 'mode',{'PhaseRand' 'nperms' NumSamples}, ...
%                 'autosave',[], ...
%                 'verb',VERBOSITY_LEVEL);
%             
%         % Phase randomized distributions are now stored in EEG.CAT.PConn
%         % This is a structure containing estimates of the connectivity etc., under 
%         % the null hypothesis of no connectivity (random phase).
%         % The distributions are stored in matrices of size:
%         % [num_vars x num_vars x num_freqs x num_times x num_samples]
%         
%         %Save resulting EEG structs
%         EEG.setname = ['FBVR_' num2str(subjnum) '_' num2str(j) '_conn_stats'];
%         pop_saveset(EEG, 'filename', ['FBVR_' num2str(subjnum) '_' num2str(j) '_conn_stats'], 'filepath', ['/data/projects/stepeter/FBVR/Data/BVR_final_noHScleaned2_conn_statsPhase']);
% 
%     end
% end